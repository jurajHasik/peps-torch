import logging
from itertools import product
from math import prod
from typing import Callable, Optional, Sequence

import torch
import numpy as np
try:
    from scipy.sparse import dok_array
except:
    print("Warning: Missing scipy. dok_array is not available.")

from groups.pg import make_c4v_symm_A1

logger = logging.getLogger("sym_ctm")


# def symmetrize_C4v_A1(a: Tensor) -> Tensor:
#     a = 0.5 * (a + backend.transpose(a, [0, 1, 4, 3, 2]))  # U-D reflection
#     a = 0.5 * (a + backend.transpose(a, [0, 3, 2, 1, 4]))  # L-R reflection
#     a = 0.5 * (a + backend.transpose(a, [0, 4, 1, 2, 3]))  # 90deg CCW rotation
#     a = 0.5 * (a + backend.transpose(a, [0, 2, 3, 4, 1]))  # 90deg CW rotation
#     return a


def generate_a_basis(
    d: int,
    D: int,
    u1_charges: Optional[list[int]] = None,
    u1_total_charge: Optional[int] = 0,
) -> torch.Tensor:
    if u1_charges is not None and u1_total_charge is not None:
        if len(u1_charges) == (d + D):
            basis = get_basis_upto_D(
                D,
                d,
                f_filter=get_u1_filter(u1_charges, u1_total_charge, d),
            )
            assert (
                len(basis) > 0
            ), f"Basis for selected D {D}, U(1) charges {u1_charges} and total charge {u1_total_charge} is empty."
            return torch.asarray(np.stack(basis).astype("double"))

        raise RuntimeError(
            f"Chosen U(1) charges {u1_charges} are not compatible with size of the virtual space {D}"
        )

    # No U(1) symmetry
    a_size = d * D * D * D * D
    a_shape = (d, D, D, D, D)
    aa = np.zeros((a_size, a_size))
    tot = 0
    for ix in range(a_size):
        new_T = np.zeros(a_size)
        new_T[ix] = 1.0
        new_T_sym = make_c4v_symm_A1(torch.asarray(new_T).reshape(a_shape)).reshape(
            -1
        )
        if not np.allclose(new_T_sym, 0.0) and np.allclose(
            torch.asarray(aa) @ new_T_sym, 0.0
        ):
            aa[tot, :] = new_T_sym
            tot += 1
    aa = aa[:tot, :]
    return torch.asarray(aa.reshape(-1, *a_shape))


def get_perm(l: Sequence[int], p: Sequence[int]):
    assert len(l) == len(p), "length of permutation p not equal to l"
    return tuple([l[x] for x in p])


def gen_A1_(seed: Sequence[int]) -> set[Sequence[int]]:
    """
    Given a 4-tuple of integers, get set of its permutations generated by the action of C4v symmetry generators
    """
    # left-right reflection, up-down reflection, pi/2 anti-clockwise, pi/2 clockwise
    return set(
        get_perm(seed, p)
        for p in [(0, 3, 2, 1), (2, 1, 0, 3), (3, 0, 1, 2), (1, 2, 3, 0)]
    )


def gen_c4v_symm_A1(
    seed: Sequence[int], f_gen: Callable = gen_A1_
) -> set[Sequence[int]]:
    """Generate orbit from single seed sequence"""
    # get initial permutations
    perms = f_gen(seed)
    if seed not in perms:
        # _gen^2
        perms.update(*[f_gen(p) for p in perms])

    # and set(_gen^3) = set(gen^2) => the orbit cannot be extended by further application of _gen
    return perms


def gen_t(D: int) -> Sequence[set[Sequence[int]]]:
    """Generate all orbits with at least one index having value D-1"""
    ts = []
    work = list(product(*([range(0, D)] * 3 + [(D - 1,)])))
    while len(work) > 0:
        ts.append(gen_c4v_symm_A1(work[0]))
        work[:] = [w for w in work if w not in ts[-1]]
    return ts


def gen_upto_D(max_D: int) -> list[Sequence[set[Sequence[int]]]]:
    """Generate all orbits with index values up max_D-1. The orbits are ordereded sequentially with growing maximal index value"""
    ts = []
    for D in range(1, max_D + 1):
        ts.append(gen_t(D))
    return ts


def get_basis_upto_D(
    max_D: int, dim_loc_H: int = 2, f_filter: Optional[Callable] = None
) -> list[np.ndarray]:
    """Generate basis tensors with bond dimension up to max_D. The physical index
    of these rank-5 tensors is assumed to be in the first position.

    Optionally, filter allowed tensors i.e. by further U(1) charge constraint.
    The signature of f_filter is f_filter(Sequence[int])->bool, testing whether a (first) tensor element
    of elementary tensors obeys charge conservation.
    ::
           u s
           |/
        l--A--r  <=> A[s,u,l,d,r]
           |
           d
    """
    basis: list[list[np.ndarray]] = [
        [] for i in range(dim_loc_H)
    ]  # holds basis for qubit DoF
    for D, D_group in enumerate(
        gen_upto_D(max_D)
    ):  # loop over groups of C4v-symmetric representatives at increasing D
        # debug
        for d in range(dim_loc_H):
            for t_set in (
                filter(lambda x: f_filter((d,) + next(iter(x))), D_group)  # type: ignore
                if f_filter
                else D_group
            ):
                _t = np.zeros((2,) + (max_D,) * 4, dtype=int)
                _t[(np.array([d] * len(t_set)),) + tuple(np.array(list(t_set)).T)] = 1
                basis[d].append(_t)
    if f_filter:
        logger.info(
            f"Constructing C4v and U(1) symmetric basis of size {sum([len(x) for x in basis])}"
        )
    else:
        logger.info(
            f"Constructing C4v symmetric basis of size {sum([len(x) for x in basis])}"
        )
    return sum(basis, [])


def get_u1_filter(
    u1_charges: Sequence[int], total_charge: int = 0, dim_loc_H: int = 2
) -> Callable:
    """
    Create a U(1) charge filter: Given an assignment of U(1) charges,
    i.e. a vector of length dim(local physical Hilbert space) + dim(virtual space) integer charges

        u1_charges= [charge(physical index=0), charge(physical index=1), ..., charge(virtual index=0), ..., charge(virtual index = D-1)]

    and assuming all signatures (in terms of standard symmetric TN formulation) of indices of on-site tensor are positive,
    return True if charge conservation is satisfied for a selected tensor element identified by its indices.
    """
    return (
        lambda inds: sum(
            [
                u1_charges[inds[0]],
            ]
            + [u1_charges[dim_loc_H + i] for i in inds[1:]]
        )
        == total_charge
    )


def rebase_params(
    params: np.ndarray, D: int, basis0: torch.Tensor, basis: torch.Tensor, rng_noise: float
) -> np.ndarray:
    # This step is done with NumPy
    """
    Map basis0 to basis (reference). Representatives of C4v basis are mutually orthogonal.
    It is assumed, that basis0 is a subset of basis, and, the common elements are related by permutation only (possibly with a rescaling)
    """

    def _to_np_if_tensor(_x) -> np.ndarray:
        if not isinstance(_x, np.ndarray):
            return np.asarray(_x)
        else:
            return _x

    basis0, basis = (  # type:ignore
        _to_np_if_tensor(arg) for arg in (basis0, basis)
    )
    overlaps = np.einsum("xpuldr,ypuldr->xy", basis0, basis[(...,) + (slice(D),) * 4])
    permutation = overlaps.nonzero()
    assert (
        len(permutation[0]) == basis0.shape[0]
    ), "Target basis (provided by instate) is not a subset of reference basis."

    # rescale params
    params = (
        params
        * np.sum(basis0.reshape(basis0.shape[0], -1) ** 2, axis=1)
        / overlaps[permutation]
    )

    # premute params to new basis and extend to basis size
    params_new = np.zeros(basis.shape[0])
    params_new = rng_noise * (np.random.rand(basis.shape[0]) - 0.5)
    params_new[permutation[1]] = params
    logger.debug(
        f"Using supplied instate to set {basis0.shape[0]} parameters in the basis with noise magnitude {rng_noise}."
    )
    return params_new


def basis_to_dict(basis: torch.Tensor | np.ndarray) -> dict:
    if not isinstance(basis, np.ndarray):
        basis_np = np.asarray(basis)
    else:
        basis_np = basis

    # Convert to dictionary-of-keys format
    basis_dok = dict(dok_array(basis_np.reshape(basis_np.shape[0], -1)))

    # Format as {ix: (<x>,<y>), value: <value>} to be JSON-serializable
    elements = [
        {"ix": (int(k[0]), int(k[1])), "value": v} for k, v in basis_dok.items()
    ]
    return {
        "shape": list(basis_np.shape),
        "elements": elements,
        "dtype": basis_np.dtype.name,
        "format": "dok",
    }


def basis_from_dict(basis_dict: dict) -> torch.Tensor:
    shape, elements, dtype = (
        basis_dict["shape"],
        basis_dict["elements"],
        np.dtype(basis_dict["dtype"]),
    )
    basis = np.zeros((shape[0], prod(shape[1:])), dtype=dtype)
    for element in elements:
        basis[tuple(element["ix"])] += element["value"]
    return torch.asarray(basis.reshape(shape))